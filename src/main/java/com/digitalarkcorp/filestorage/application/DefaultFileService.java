package com.digitalarkcorp.filestorage.application;

import com.digitalarkcorp.filestorage.api.dto.ListQuery;
import com.digitalarkcorp.filestorage.api.dto.RenameRequest;
import com.digitalarkcorp.filestorage.api.errors.BadRequestException;
import com.digitalarkcorp.filestorage.api.errors.ConflictException;
import com.digitalarkcorp.filestorage.api.errors.ForbiddenException;
import com.digitalarkcorp.filestorage.api.errors.NotFoundException;
import com.digitalarkcorp.filestorage.domain.FileMetadata;
import com.digitalarkcorp.filestorage.domain.FileStatus;
import com.digitalarkcorp.filestorage.domain.Visibility;
import com.digitalarkcorp.filestorage.domain.ports.MetadataRepository;
import com.digitalarkcorp.filestorage.domain.ports.StoragePort;

import java.io.InputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.HexFormat;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

public class DefaultFileService implements FileService {

    private final MetadataRepository repo;
    private final StoragePort storage;

    public DefaultFileService(MetadataRepository repo, StoragePort storage) {
        this.repo = Objects.requireNonNull(repo);
        this.storage = Objects.requireNonNull(storage);
    }

    @Override
    public FileMetadata upload(String ownerId,
                               String filename,
                               Visibility visibility,
                               List<String> tags,
                               String contentType,
                               InputStream content,
                               long size) {
        if (ownerId == null || ownerId.isBlank()) throw new BadRequestException("Missing owner");
        if (filename == null || filename.isBlank()) throw new BadRequestException("Filename is required");
        if (visibility == null) throw new BadRequestException("Visibility is required");
        if (content == null) throw new BadRequestException("File content is required");
        if (size < 0) throw new BadRequestException("Invalid size");

        // Dup by (ownerId + filename)
        repo.findByOwnerAndFilename(ownerId, filename).ifPresent(existing -> {
            throw new ConflictException("Filename already exists for this owner");
        });

        Path temp = null;
        try {
            // Compute SHA-256 while copying to a temp file
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            temp = Files.createTempFile("upload-", ".bin");
            try (DigestInputStream din = new DigestInputStream(content, sha256)) {
                Files.copy(din, temp, java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            }
            long effectiveSize = (size > 0) ? size : Files.size(temp);
            String contentHash = HexFormat.of().formatHex(sha256.digest());

            // Dup by (ownerId + contentHash)
            repo.findByOwnerAndContentHash(ownerId, contentHash).ifPresent(existing -> {
                throw new ConflictException("A file with the same content already exists for this owner");
            });

            String linkId = UUID.randomUUID().toString();
            String uploadId = storage.initiate(linkId);
            try (InputStream in = Files.newInputStream(temp)) {
                storage.uploadPart(uploadId, 1, in, effectiveSize);
            }
            storage.complete(uploadId);

            Instant now = Instant.now();
            FileMetadata model = new FileMetadata(
                    null,                 // id generated by Mongo
                    ownerId,
                    filename,
                    visibility,
                    tags,
                    effectiveSize,
                    contentType != null && !contentType.isBlank() ? contentType : "application/octet-stream",
                    contentHash,
                    linkId,
                    FileStatus.READY,
                    now,
                    now
            );
            return repo.save(model);
        } catch (ConflictException | BadRequestException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Failed to complete upload", e);
        } finally {
            if (temp != null) {
                try {
                    Files.deleteIfExists(temp);
                } catch (IOException ignore) {
                    // best-effort
                }
            }
        }
    }

    @Override
    public List<FileMetadata> listByOwner(String ownerId, ListQuery query) {
        if (ownerId == null || ownerId.isBlank()) throw new BadRequestException("Missing owner");
        return repo.listByOwner(
                ownerId,
                query.tag(),
                query.sortBy(),
                query.sortDir(),
                query.page(),
                query.size()
        );
    }

    @Override
    public List<FileMetadata> listPublic(ListQuery query) {
        return repo.listPublic(
                query.tag(),
                query.sortBy(),
                query.sortDir(),
                query.page(),
                query.size()
        );
    }

    @Override
    public FileMetadata rename(String ownerId, String id, RenameRequest request) {
        if (ownerId == null || ownerId.isBlank()) throw new BadRequestException("Missing owner");
        if (id == null || id.isBlank()) throw new BadRequestException("Missing id");
        if (request == null || request.newFilename() == null || request.newFilename().isBlank()) {
            throw new BadRequestException("New filename is required");
        }

        FileMetadata current = repo.findById(id).orElseThrow(() -> new NotFoundException("File not found"));
        if (!ownerId.equals(current.ownerId())) throw new ForbiddenException("Not the owner");

        repo.findByOwnerAndFilename(ownerId, request.newFilename()).ifPresent(other -> {
            if (!other.id().equals(id)) {
                throw new ConflictException("Filename already exists for this owner");
            }
        });

        FileMetadata updated = new FileMetadata(
                current.id(),
                current.ownerId(),
                request.newFilename(),
                current.visibility(),
                current.tags(),
                current.size(),
                current.contentType(),
                current.contentHash(),
                current.linkId(),
                current.status(),
                current.createdAt(),
                Instant.now()
        );
        return repo.save(updated);
    }

    @Override
    public InputStream downloadByLink(String linkId) {
        if (linkId == null || linkId.isBlank()) throw new BadRequestException("Missing linkId");
        FileMetadata m = repo.findByLinkId(linkId).orElseThrow(() -> new NotFoundException("File not found"));
        return storage.get(m.linkId());
    }

    @Override
    public void delete(String ownerId, String id) {
        if (ownerId == null || ownerId.isBlank()) throw new BadRequestException("Missing owner");
        if (id == null || id.isBlank()) throw new BadRequestException("Missing id");

        FileMetadata m = repo.findById(id).orElseThrow(() -> new NotFoundException("File not found"));
        if (!ownerId.equals(m.ownerId())) throw new ForbiddenException("Not the owner");

        storage.delete(m.linkId());
        repo.deleteById(id);
    }
}
